<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 疯狂coding</title>
    <link>http://localhost:1313/post/</link>
    <description>Recent content in Posts on 疯狂coding</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>guonaihong</copyright>
    <lastBuildDate>Wed, 20 Jan 2021 11:40:26 +0800</lastBuildDate><atom:link href="http://localhost:1313/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>老瓶装新酒--使用makefile优化你的工作流</title>
      <link>http://localhost:1313/post/using-makefile-to-manage-your-workflow/</link>
      <pubDate>Wed, 20 Jan 2021 11:40:26 +0800</pubDate>
      
      <guid>http://localhost:1313/post/using-makefile-to-manage-your-workflow/</guid>
      <description>前言 Makefile主要出现在c/c++的项目居多，用来管理c/c++的编译依赖。 这里的用法有点非主流的感觉，但是经过本人的实践。用好Mak</description>
    </item>
    
    <item>
      <title>golang bool类型是怎么实现的</title>
      <link>http://localhost:1313/post/what-type-of-implementation-is-golang-bool/</link>
      <pubDate>Mon, 18 Jan 2021 11:54:39 +0800</pubDate>
      
      <guid>http://localhost:1313/post/what-type-of-implementation-is-golang-bool/</guid>
      <description>前言 wc的时候突然蹦出一个想法，golang bool是什么类型实现的。会和c一样吗？ 既然有疑问，就做个实验看下。 如果bool的值为true，</description>
    </item>
    
    <item>
      <title>Rfc7230 Header</title>
      <link>http://localhost:1313/post/rfc7230-header/</link>
      <pubDate>Sat, 16 Jan 2021 16:50:12 +0800</pubDate>
      
      <guid>http://localhost:1313/post/rfc7230-header/</guid>
      <description>前言 这个笔记是看rfc7230对于http header的解析器描述。 一、header Fields https://tools.ietf.org/html/rfc7230#section-3.2.1 &amp;quot;:&amp;quot;分隔field和value</description>
    </item>
    
    <item>
      <title>Rfc7230 Chunk</title>
      <link>http://localhost:1313/post/rfc7230-chunk/</link>
      <pubDate>Sat, 16 Jan 2021 15:34:54 +0800</pubDate>
      
      <guid>http://localhost:1313/post/rfc7230-chunk/</guid>
      <description>前言 rfc7230是替换rfc2616的文档，主要描述http 1.1相关内容。本文是学习http chunk封装格式笔记。 http 引入chunk，可</description>
    </item>
    
    <item>
      <title>Rfc7230 专有名词</title>
      <link>http://localhost:1313/post/rfc7230-syntax-notation/</link>
      <pubDate>Thu, 14 Jan 2021 18:42:59 +0800</pubDate>
      
      <guid>http://localhost:1313/post/rfc7230-syntax-notation/</guid>
      <description>记录下rfc7230的一些名词 https://tools.ietf.org/html/rfc7230#section-4 专有词解释 ALPHA 1 a &amp;gt;= &amp;#39;a&amp;#39; &amp;amp;&amp;amp; a &amp;lt;= &amp;#39;z&amp;#39; || a &amp;gt;= &amp;#39;A&amp;#39; &amp;amp;&amp;amp; a &amp;lt;= &amp;#39;Z&amp;#39; CR 1 &amp;#39;\r&amp;#39; CRLF 1 &amp;#34;\r\n&amp;#34; CTL TODO DIGIT 1 a &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; a &amp;lt;= &amp;#39;9&amp;#39; DQUOTE 1 &amp;#34; HEXDIG 1 (hexadecimal 0-9/A-F/a-f) HTAB 1 &amp;#39;\t&amp;#39; LF 1 &amp;#39;\n&amp;#39; OCTET 1</description>
    </item>
    
    <item>
      <title>Raw Ptr to Slice</title>
      <link>http://localhost:1313/post/raw-ptr-to-slice/</link>
      <pubDate>Thu, 14 Jan 2021 15:10:53 +0800</pubDate>
      
      <guid>http://localhost:1313/post/raw-ptr-to-slice/</guid>
      <description>前言 最近在rust 调用c的时候遇到一个坑，需要从c里面把char *转成rust的slice类型。 最初使用CStr::from_ptr函数,最</description>
    </item>
    
    <item>
      <title>Trait and Dyn</title>
      <link>http://localhost:1313/post/trait-and-dyn/</link>
      <pubDate>Thu, 07 Jan 2021 15:05:24 +0800</pubDate>
      
      <guid>http://localhost:1313/post/trait-and-dyn/</guid>
      <description>一、trait trait有点类似go的interface，但和go的接口有点不一样，他是静态分发的。静态分发可能有点不好理解。下面聊dyn就</description>
    </item>
    
    <item>
      <title>Tcp Protobuf and Server</title>
      <link>http://localhost:1313/post/tcp-protobuf-and-server/</link>
      <pubDate>Mon, 04 Jan 2021 16:35:27 +0800</pubDate>
      
      <guid>http://localhost:1313/post/tcp-protobuf-and-server/</guid>
      <description>前言 在tcp使用可扩展的私有协议，通常使用TLV(length type value)设计方式。L解决TCP粘包问题。TV提供扩展能力。接下来本笔记使</description>
    </item>
    
    <item>
      <title>rust tcp模板代码--Rust Tcp Client and Server Template</title>
      <link>http://localhost:1313/post/rust-tcp-client-and-server-template/</link>
      <pubDate>Wed, 30 Dec 2020 14:51:29 +0800</pubDate>
      
      <guid>http://localhost:1313/post/rust-tcp-client-and-server-template/</guid>
      <description>前言 tcp是现在通信的基础，在http3没有到来之前这句话还是很对的。 因为tcp是流式传输，客户端一次write 1600个字节，服务端也许只</description>
    </item>
    
    <item>
      <title>rust 泛型函数笔记-Rust Generics Func</title>
      <link>http://localhost:1313/post/rust-generics-func/</link>
      <pubDate>Tue, 29 Dec 2020 13:05:58 +0800</pubDate>
      
      <guid>http://localhost:1313/post/rust-generics-func/</guid>
      <description>一、泛型概念 泛型很多编程语言都会实现的特性。在处理数据结构的时候可以带来很大便利性。或者一些工具函数可以处理多种类型。 当然熟悉go的童鞋，可</description>
    </item>
    
    <item>
      <title>Wait for the Process to End</title>
      <link>http://localhost:1313/post/wait-for-the-process-to-end/</link>
      <pubDate>Mon, 28 Dec 2020 13:45:06 +0800</pubDate>
      
      <guid>http://localhost:1313/post/wait-for-the-process-to-end/</guid>
      <description>一、前言 前面结束过使用fork()创建多个进程，使用sem_open(), sem_wait(), sem_post()保护临界区资源。 但是遗漏了一个重要的事情，如</description>
    </item>
    
    <item>
      <title>Name Semaphore as Process Lock</title>
      <link>http://localhost:1313/post/name-semaphore-as-process-lock/</link>
      <pubDate>Fri, 25 Dec 2020 15:31:11 +0800</pubDate>
      
      <guid>http://localhost:1313/post/name-semaphore-as-process-lock/</guid>
      <description>前言 最近需要在rust里面使用多进程，有进程锁是第一步，毕竟进入临界区不能裸奔。 如果遥远的记忆没有出错，fcntl基于fd也可以实现进程锁，</description>
    </item>
    
    <item>
      <title>Call C Dynamic Library in Rust Bindgen 2</title>
      <link>http://localhost:1313/post/call-c-dynamic-library-in-rust-bingen-2/</link>
      <pubDate>Wed, 23 Dec 2020 14:43:59 +0800</pubDate>
      
      <guid>http://localhost:1313/post/call-c-dynamic-library-in-rust-bingen-2/</guid>
      <description>前言 在Call C dynamic library in rust文章里面已经介绍了手动绑定c头文件到rust里面， 这下终于可以在rust里面使用c语言遗产。但是这里有个问题，</description>
    </item>
    
    <item>
      <title>Call C dynamic library in rust</title>
      <link>http://localhost:1313/post/call-c-dynamic-library-in-rust/</link>
      <pubDate>Mon, 21 Dec 2020 15:08:12 +0800</pubDate>
      
      <guid>http://localhost:1313/post/call-c-dynamic-library-in-rust/</guid>
      <description>前言 c语言作为系统编程语言统治bit世界已经很久，留下了大量的代码遗产。rust作为新兴语言在一些冷门领域开发，真是裹足前行。rust如果可</description>
    </item>
    
  </channel>
</rss>
